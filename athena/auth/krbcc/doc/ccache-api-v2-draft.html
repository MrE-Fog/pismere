<HTML>
<HEAD>
   <TITLE>Draft specification for the Credentials Cache API</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"><ISINDEX >
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<H2><CENTER>Kerberos Credentials Cache API draft specification
</CENTER></H2>

<H2><CENTER>API Version 2</CENTER></H2>

<H2><CENTER><FONT COLOR="#FF0000">* DRAFT -- This not finalized
*</FONT></CENTER></H2>

<P><CENTER>
<HR>
</CENTER></P>

<UL>
   <LI><A HREF="#TypeDefinitions">Type Definitions</A>
   
   <UL>
      <LI><A HREF="#cc_int32">cc_int32 &amp; cc_uint32</A>
      
      <LI><A HREF="#cc_time_t">cc_time_t</A>
      
      <LI><A HREF="#cc_nc_flags">cc_nc_flags</A>
      
      <LI><A HREF="#typedefCC_Cred">cc_cred</A>
      
      <LI><A HREF="#typedefCC_Data">cc_data</A>
      
      <LI><A HREF="#typedefV4Cred_type">V4Cred_type</A>
      
      <LI><A HREF="#enumStringToKey_Type">StringToKey_Type</A>
      
      <LI><A HREF="#enumCc_cred_vers">cc_cred_vers</A>
      
      <LI><A HREF="#unionCred_ptr_union">cred_ptr_union</A>
      
      <LI><A HREF="#unionCred_union">cred_union</A>
      
      <LI><A HREF="#typdefInfoNC">infoNC</A>
      
      <LI><A HREF="#opaque_types">opaque types</A>
   </UL>
   
   <LI><A HREF="#ErrorCodeDefinitions">Error Code Definitions</A>
   
   <LI><A HREF="#ImplementationNotes">Implementation Notes</A>
   
   <LI><A HREF="#FunctionDefinitions">Function Definitions</A>
   
   <UL>
      <LI><A HREF="#MainCacheFunctions">Main Cache Functions</A>
      
      <UL>
         <LI><A HREF="#cc_initialize">cc_initialize</A>
         
         <LI><A HREF="#cc_create">cc_create</A>
         
         <LI><A HREF="#cc_open">cc_open</A>
         
         <LI><A HREF="#cc_close">cc_close</A>
         
         <LI><A HREF="#cc_destroy">cc_destroy</A>
         
         <LI><A HREF="#cc_shutdown">cc_shutdown</A>
         
         <LI><A HREF="#cc_initialize">cc_initialize</A>
         
         <LI><A HREF="#cc_get_instance">cc_get_instance</A>
         
         <LI><A HREF="#cc_free_instance">cc_free_instance</A>
         
         <LI><A HREF="#cc_get_change_time">cc_get_change_time</A>
         
         <LI><A HREF="#cc_get_NC_info">cc_get_NC_info</A>
         
         <LI><A HREF="#cc_seq_fetch_NCs_begin">cc_seq_fetch_NCs_begin</A>
         
         <LI><A HREF="#cc_seq_fetch_NCs_next">cc_seq_fetch_NCs_next</A>
         
         <LI><A HREF="#cc_seq_fetch_NCs_end">cc_seq_fetch_NCs_end</A>
      
      </UL>
      
      <LI><A HREF="#NCFunctions">NC Functions</A>
      
      <UL>
         <LI><A HREF="#cc_get_name">cc_get_name</A>
         
         <LI><A HREF="#cc_get_cred_version">cc_get_cred_version</A>
         
         <LI><A HREF="#cc_get_principal">cc_get_principal</A>
         
         <LI><A HREF="#cc_get_instance">cc_get_instance</A>
         
         <LI><A HREF="#cc_remove_cred">cc_remove_cred</A>
         
         <LI><A HREF="#cc_store">cc_store</A>
         
         <LI><A HREF="#cc_get_instance">cc_get_instance</A>
         
         <LI><A HREF="#cc_seq_fetch_creds_begin">cc_seq_fetch_creds_begin</A>
         
         <LI><A HREF="#cc_seq_fetch_creds_next">cc_seq_fetch_creds_next</A>
         
         <LI><A HREF="#cc_seq_fetch_creds_end">cc_seq_fetch_creds_end</A>
         
         <LI><A HREF="#cc_lock_request">cc_lock_request</A>
      </UL>
      
      <LI><A HREF="#LiberationFunctions">Liberation Functions</A>
      
      <UL>
         <LI><A HREF="#cc_free_principal">cc_free_principal</A>
         
         <LI><A HREF="#cc_free_name">cc_free_name</A>
         
         <LI><A HREF="#cc_free_creds">cc_free_creds</A>
         
         <LI><A HREF="#cc_free_NC_info">cc_free_NC_info</A>
      </UL>
   </UL>
   
   <LI><A HREF="#RevisionNotes">Revision History/Notes</A>
   
   <UL>
      <LI><A HREF="#ChangesRev3">Changes made during revsion 3</A>
   </UL>
   
   <LI><A HREF="#FutureIdeas">Ideas for Future Versions</A>
   
   <LI><A HREF="#Abstract">Abstract</A>
</UL>

<P>
<HR>
<A NAME="Abstract"></A></P>

<H2>Abstract</H2>

<P>This is a draft specification for <I>an API</I> which provides
Credentials Cache services for both
<A HREF="http://web.mit.edu/kerberos/www/">Kerberos V5</A> and V4.
The idea behind this <I>API</I> is that multiple Kerberos
implementations can share a single Credentials Cache, mediated by
this <I>API</I> specification. <I>On the Microsoft Windows
platform</I> this will allow single-signon, even when more than one
Kerberos DLL is in use on a particular system. Ideally, this problem
could be solved by standardizing the Kerberos V5 API library
interface. However, the Kerberos API is complicated enough that this
would be hard to accomplish. Standardizing the interface for
credentials cache access is much simpler.</P>

<P>This specification has been revised to allow storage and
manipulation of both V4 and V5 tickets. A cache contains one or more
"Named Cache"s. It is assumed that V4 and V5 credentials would each
be stored in separate "Named Cache"s and not mixed in a single "Named
Cache".</P>

<P>Below, "NC" refers to "Named Cache".<BR>

</P>

<P>
<HR>
<A NAME="RevisionNotes"></A></P>

<H2><B>Revision History/Notes</B></H2>

<H4>Original version</H4>

<P>1/27/96 by
<A HREF="http://web.mit.edu/tytso/www/home.html">Theodore Ts'o</A>
</P>

<H4>Revision 2</H4>

<P>970628 by <A HREF="http://www.umich.edu/~sgr">Steve Rothwell</A>
for the V4Cache Team (Paul Hill, Jenny Khuon, Jean Luker, Dave
Detlefs, Allan Bjorklund, &amp; Steve Rothwell)</P>

<P><A NAME="ChangesRev3"></A></P>

<H4>Revision 3</H4>

<P>970725 by Steve Rothwell after initial implementation and alpha
release. The term "credentials cache" was previously used to mean
both "the main cache" and individual "named cache"s within the main
cache. I have started using the term "NC" for "named cache" to make
the distinction clearer and to reduce the overloading of the word
"cache".</P>

<H5>Changes made for revision 3 of this API:</H5>

<UL>
   <LI>Added cred version type to cc_create() &amp; cc_open()
   
   <LI>New functions
   
   <UL>
      <LI>cc_get_NC_info(), returns NC_info list for all NCs
      
      <LI>cc_free_NC_info(), frees NC_info list
      
      <LI>cc_get_cred_version(), returns version type of NC
      
      <LI>cc_get_name(), returns name of NC
      
      <LI>cc_free_name(), frees name aquired via cc_get_name()
      
      <LI>cc_seq_fetch_NCs(), iterate over all NCs
   </UL>
   
   <LI>New return codes
   
   <UL>
      <LI>CC_BAD_PARM
      
      <LI>CC_ERR_CACHE_ATTACH
      
      <LI>CC_ERR_CACHE_RELEASE
      
      <LI>CC_ERR_CACHE_FULL
      
      <LI>CC_ERR_CRED_VERSION
   </UL>
   
   <LI>Modified functions
   
   <UL>
      <LI>cc_create(), cc_open(), pass version type of NC
      
      <LI>cc_store(), cc_remove(), cc_
   </UL>
   
   <LI>New &amp; Modified typedefs &amp; data structures
   
   <UL>
      <LI>cc_cred_vers { CC_CRED_VUNKNOWN, CC_CRED_V4, CC_CRED_V5 }
      
      <LI>cred_ptr_union : contains pointer to credentials (either V4
      or V5)
      
      <LI>cred_union : contains version type and cred_ptr_union
      
      <LI>modified V4Cred_type
      
      <LI>enum StringToKey_Type { STK_AFS or STK_DES }
      
      <LI>copies of the maximum V4 string size indicators
      KRB_PRINCIPAL_SZ, KRB_SERVICE_SZ, KRB_INSTANCE_SZ,
      KRB_REALM_SZ, ADDR_SZ
   </UL>
</UL>

<H4>Revision 4</H4>

<P>970908 by Steve Rothwell to incorporate changes initiated by Ted
Tso. Further changes are expected in the comments for cc_create() and
cc_get_change_time().</P>

<H4>Revision 4a</H4>

<P>980603 by <A HREF="mailto:smcguire@mit.edu">Scott McGuire</A> to
correct typographical errors, HTML errors, and minor clarifications.
Final API Version 1 spec.</P>

<H4>Revision 5</H4>

<P>990201 by <A HREF="mailto:smcguire@mit.edu">Scott McGuire</A>.
Changes are marked in <FONT COLOR="#FF0000">red</FONT>. In summary:
</P>

<UL>
   <LI>Increased API version number to 2.
   
   <LI>Added enum's defining version numbers.
   
   <LI>Changes to cc_initialize() to specify how to deal with
   different API version numbers.
   
   <LI>Added description of cc_int32 and cc_uint32 types.
   
   <LI>Change some cc_int32's to cc_uint32's (all marked in <FONT
   COLOR="#FF0000">red</FONT>).
   
   <LI>Changed way cc_create() will behave when called on an existing
   cache.
   
   <LI>Replaced cc_seq_fetch_NCs() with cc_seq_fetch_NCs_begin(),
   cc_seq_fetch_NCs_next(), and cc_seq_fetch_NCs_end();
   
   <LI>Replaced cc_seq_fetch_creds() with cc_seq_fetch_creds_begin(),
   cc_seq_fetch_creds_next(), and cc_seq_fetch_creds_end();
   
   <LI>Replaced enum type references in structs and function
   paramenters with cc_int32 references;
   
   <LI>Replaced int type references in function parameters with
   cc_int32;
   
   <LI>Added return type of cc_int32 to all functions;
   
   <LI>Removed #ifdef from cred_union structure;
   
   <LI>Constant definitions and changes to V4Cred_type structure;
   
   <LI>Removed incorrect const ccache_p * parameters from cc_store()
   and cc_remove_cred();
   
   <LI>Added CC_NOERROR and CC_BAD_PARM as possible return codes from
   all functions (except no CC_BAD_PARM from cc_shutdown() );
   
   <LI>Added CC_ERR_CRED_VERSION as possible return code from
   cc_open() and cc_create();
   
   <LI>Moved infoNC structure definition up to be with rest of
   structure definitions;
   
   <LI>Changed "struct _infoNC" to "infoNC" in parameter type
   references.
   
   <LI>cc_free_principal() and cc_free_name() now take char **
   instead of char * for final parameter. (This change was made
   between rev 4a and rev 5, but I'm re-emphasizing it here.)
   
   <LI>Added Implementation Notes section with requirement that all
   functions must be atomic and name requirements for Windows DLL's.
   
   <LI>Renamed "the proposed changes to this API are" section to
   "Ideas for Future Versions" -- but removed all items but one
   because they'd all been done.
   
   <LI>Removed most of the notes about differences with the Win NT/95
   implementation of the API -- the differences have been
   reconciled.
   
   <LI>Removed unnecessary and inconsistent italicizing.
</UL>

<H2><FONT COLOR="#FF0000"><A NAME="FutureIdeas"></A></FONT>Ideas for
Future Versions</H2>

<UL>
   <LI>Define Get/Set functions for all components of _cc_creds?
   (This will allow future changes to the data structure to be
   transparent to the caller. This also makes backward compatibility
   much easier to maintain.)
</UL>

<P><!-- -----------------------------------------------------------------------------------><!-- type definitions                                                                 --><!-- -----------------------------------------------------------------------------------><BR>


<HR>
<A NAME="TypeDefinitions"></A></P>

<H2>Type definitions</H2>

<PRE><FONT
COLOR="#FF0000">// enums for API versions used in cc_initialize()
enum {
   CC_API_VER_1 = 1,
   CC_API_VER_2 = 2
};</FONT>
&nbsp;
<A NAME="cc_int32"></A><FONT COLOR="#FF0000">
// cc_int32 and cc_uint32 are not exactly defined in this API due
// to a lack of standard 32-bit integer size between platforms
// (although there is the C9X standard).
// However, we will place the following constraints:
//
// cc_int32 is a signed integer that is at least 32 bits wide.
// cc_uint32 is an unsigned integer that is at least 32 bits wide</FONT>
&nbsp;
<A NAME="cc_time_t"></A>
typedef cc_int32 cc_time_t;  //see <A HREF="#cc_time_t_Note">notes below</A>
<A NAME="cc_nc_flags"></A><FONT COLOR="#FF0000">
typedef cc_uint32 cc_nc_flags;</FONT>
&nbsp;
&nbsp;
<A NAME="opaque_types"></A>
typedef struct opaque_dll_control_block_type* apiCB;
typedef struct opaque_ccache_pointer_type* ccache_p;
typedef struct opaque_credential_iterator_type* ccache_cit;
&nbsp;
// These really are intended to be opaque. All implementations of the cache API must have
// them but what they are is implementation specific. In the case of SGR's implementation,
// the cc_ctx returned available after a call to cc_initialize, is a CCache_ctx class object. The&nbsp;
// code that normally calls the cc_initialize function is straight C, which means the calling
// application doesn't have a chance in hell of manipulating this directly. The API is designed
// so that it does not have to. It does have to pass the pointer to the class around, one reason&nbsp;
// being so that the destructor can eventually be called.
&nbsp;
&nbsp;
<A NAME="typedefCC_Data"></A>
typedef struct _cc_data {
&nbsp;&nbsp;&nbsp; <FONT
COLOR="#FF0000">cc_uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type;</FONT>
&nbsp;&nbsp;&nbsp; <FONT
COLOR="#FF0000">cc_uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length;</FONT>
&nbsp;&nbsp;&nbsp; unsigned char*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data;
} cc_data;
&nbsp;
<A NAME="typedefCC_Cred"></A>
typedef struct _cc_creds {
&nbsp;&nbsp;&nbsp; char*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client; /* client's principal identifier */
&nbsp;&nbsp;&nbsp; char*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; server; /* server's principal identifier */
&nbsp;&nbsp;&nbsp; cc_data&nbsp;&nbsp;&nbsp;&nbsp; keyblock;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* session encryption key info */
&nbsp;&nbsp;&nbsp; cc_time_t&nbsp;&nbsp; authtime;
&nbsp;&nbsp;&nbsp; cc_time_t&nbsp;&nbsp; starttime;
&nbsp;&nbsp;&nbsp; cc_time_t&nbsp;&nbsp; endtime;
&nbsp;&nbsp;&nbsp; cc_time_t&nbsp;&nbsp; renew_till;
&nbsp;&nbsp;&nbsp; <FONT
COLOR="#FF0000">cc_uint32&nbsp;&nbsp;&nbsp; is_skey;</FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* true if ticket is encrypted in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; another ticket's skey */
&nbsp;&nbsp;&nbsp; <FONT
COLOR="#FF0000">cc_uint32&nbsp;&nbsp;&nbsp; ticket_flags;</FONT>&nbsp;&nbsp; /* flags in ticket */
&nbsp;&nbsp;&nbsp; cc_data**&nbsp;&nbsp; addresses;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* addrs in ticket */
&nbsp;&nbsp;&nbsp; cc_data&nbsp;&nbsp;&nbsp;&nbsp; ticket;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ticket string itself */
&nbsp;&nbsp;&nbsp; cc_data&nbsp;&nbsp;&nbsp;&nbsp; second_ticket;&nbsp; /* second ticket, if related to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ticket (via DUPLICATE-SKEY or
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENC-TKT-IN-SKEY) */
&nbsp;&nbsp;&nbsp; cc_data**&nbsp;&nbsp; authdata;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* authorization data */
} cc_creds;
&nbsp;
&nbsp;
// use an enumerated type so all callers infer the same meaning
// these values are what krbv4win uses internally.
<A NAME="enumStringToKey_Type"></A>
enum StringToKey_Type { STK_AFS = 0, STK_DES = 1 };
&nbsp;
enum { MAX_V4_CRED_LEN = 1250 };
&nbsp;
&nbsp;
// V4 Credentials
<A NAME="typedefV4Cred_type"></A><FONT COLOR="#FF0000">
enum {
&nbsp;&nbsp;KRB_NAME_SZ = 40,
&nbsp;&nbsp;KRB_INSTANCE_SZ = 40,
&nbsp;&nbsp;KRB_REALM_SZ = 40
};</FONT>
&nbsp;
typedef struct _V4credential {
&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;      kversion;
&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;     principal[<FONT
COLOR="#FF0000">KRB_NAME_SZ+1</FONT>];
&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;     principal_instance[<FONT
COLOR="#FF0000">KRB_INSTANCE_SZ+1</FONT>];
&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;     service[<FONT
COLOR="#FF0000">KRB_NAME_SZ+1</FONT>];
&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;     service_instance[<FONT
COLOR="#FF0000">KRB_INSTANCE_SZ+1</FONT>];
&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;     realm[<FONT
COLOR="#FF0000">KRB_REALM_SZ+1</FONT>];
&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        session_key[8];
&nbsp;&nbsp;&nbsp; cc_int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        kvno;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // k95 used BYTE skvno
&nbsp;&nbsp;&nbsp; <FONT
COLOR="#FF0000">cc_int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str_to_key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// k4 infers dynamically, k95 stores; of type enum StringToKey_Type</FONT>
&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     issue_date;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // k95 called this issue_time
&nbsp;&nbsp;&nbsp; cc_int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        lifetime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // k95 used LONG expiration_time<FONT
COLOR="#FF0000">
&nbsp;&nbsp;&nbsp; cc_uint32    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;       // IP Address of local host as an unsigned 32-bit integer</FONT>
&nbsp;&nbsp;&nbsp; cc_int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ticket_sz;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // k95 used BYTE, k4 ktext uses int to hold up to 1250
&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ticket[MAX_V4_CRED_LEN];
&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        oops;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // zero to catch runaways
} V4Cred_type;
&nbsp;
<A NAME="enumCc_cred_vers"></A>
enum cc_cred_vers {&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; CC_CRED_VUNKNOWN = 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // For validation
&nbsp;&nbsp;&nbsp; CC_CRED_V4 = 1,
&nbsp;&nbsp;&nbsp; CC_CRED_V5 = 2,
&nbsp;&nbsp;&nbsp; CC_CRED_VMAX = 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // For validation
};
&nbsp;
<A NAME="unionCred_ptr_union"></A>
typedef union cred_ptr_union_type {
&nbsp;&nbsp;&nbsp; V4Cred_type* pV4Cred;
&nbsp;&nbsp;&nbsp; cc_creds*&nbsp;&nbsp;&nbsp; pV5Cred;
} cred_ptr_union;
&nbsp;
<A NAME="unionCred_union"></A><FONT COLOR="#FF0000">
typedef struct cred_union_type {
&nbsp;&nbsp;&nbsp; cc_int32 cred_type;  // cc_cred_vers
&nbsp;&nbsp;&nbsp; </FONT><FONT
COLOR="#FF0000"><A HREF="#unionCred_ptr_union">cred_ptr_union</A></FONT><FONT
COLOR="#FF0000"> cred;
} cred_union;</FONT>
&nbsp;
<A NAME="typdefInfoNC"></A>
typedef struct _infoNC {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char*&nbsp;&nbsp; name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char*&nbsp;&nbsp; principal;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT
COLOR="#FF0000">cc_int32 vers;   // cc_cred_vers</FONT>
} infoNC;</PRE>

<H4>The cc_data structure</H4>

<P>The cc_data structure is used to store the following elements:
</P>

<UL>
   <LI>keyblock
   
   <LI>addresses
   
   <LI>ticket (and second_ticket)
   
   <LI>authorization data
</UL>

<P>For cc_creds.ticket and cc_creds.second_ticket, the cc_data.type
field MUST be zero. For the cc_creds.addresses, cc_creds.authdata,
and cc_data.keyblock, the cc_data.type field should be the address
type, authorization data type, and encryption type, as defined by the
Kerberos V5 protocol definition.</P>

<H4><A NAME="cc_time_t_Note"></A>cc_time_t</H4>

<P>The cc_time_t fields are used to represent time. The time <FONT
COLOR="#FF0000">must</FONT> be stored as the number of seconds since
midnight GMT on January 1, 1970.</P>

<H4>Principal names</H4>

<P>Principal names are stored as C strings in this API. The C strings
may contain UTF-8 encoded strings for internationalization
purposes.<BR>


<HR>
<A NAME="ErrorCodeDefinitions"></A></P>

<H2>Error Codes Definition</H2>

<P><TABLE BORDER=1>
   <TR>
      <TD>
         <P>0&nbsp;
      </TD><TD>
         <P>CC_NOERROR&nbsp;
      </TD><TD>
         <P>"Successful return"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>1&nbsp;
      </TD><TD>
         <P>CC_BADNAME&nbsp;
      </TD><TD>
         <P>"Bad credential cache name format"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>2&nbsp;
      </TD><TD>
         <P>CC_NOTFOUD&nbsp;
      </TD><TD>
         <P>"Matching credential not found"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>3&nbsp;
      </TD><TD>
         <P>CC_END&nbsp;
      </TD><TD>
         <P>"End of credential cache reached"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>4&nbsp;
      </TD><TD>
         <P>CC_IO&nbsp;
      </TD><TD>
         <P>"Credentials cache I/O operation failed"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>5&nbsp;
      </TD><TD>
         <P>CC_WRITE&nbsp;
      </TD><TD>
         <P>"Error writing to credentials cache file"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>6&nbsp;
      </TD><TD>
         <P>CC_NOMEM&nbsp;
      </TD><TD>
         <P>"No memory"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>7&nbsp;
      </TD><TD>
         <P>CC_FORMAT&nbsp;
      </TD><TD>
         <P>"Corrupted credentials cache"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>8&nbsp;
      </TD><TD>
         <P>CC_LOCKED&nbsp;
      </TD><TD>
         <P>"The credentials cache or NC is locked"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>9&nbsp;
      </TD><TD>
         <P>CC_BAD_API_VERSION&nbsp;
      </TD><TD>
         <P>"Unsupported API version"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>10&nbsp;
      </TD><TD>
         <P>CC_NO_EXIST&nbsp;
      </TD><TD>
         <P>"Credentials cache or NC does not exist"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>11&nbsp;
      </TD><TD>
         <P>CC_NOT_SUPP&nbsp;
      </TD><TD>
         <P>"Function not supported"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>12&nbsp;
      </TD><TD>
         <P>CC_BAD_PARM&nbsp;
      </TD><TD>
         <P>"Bad Paramter Passed"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>13&nbsp;
      </TD><TD>
         <P>CC_ERR_CACHE_ATTACH&nbsp;
      </TD><TD>
         <P>"Failed to attach cache"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>14&nbsp;
      </TD><TD>
         <P>CC_ERR_CACHE_RELEASE&nbsp;
      </TD><TD>
         <P>"Failed to release cache"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>15&nbsp;
      </TD><TD>
         <P>CC_ERR_CACHE_FULL&nbsp;
      </TD><TD>
         <P>"Cache FULL"&nbsp;
      </TD></TR>
   <TR>
      <TD>
         <P>16&nbsp;
      </TD><TD>
         <P>CC_ERR_CRED_VERSION&nbsp;
      </TD><TD>
         <P>"Wrong Cred Version"&nbsp;
      </TD></TR>
</TABLE></P>

<P>
<HR>
<A NAME="ImplementationNotes"></A></P>

<H2><FONT COLOR="#FF0000">Implementation Notes</FONT></H2>

<H4><FONT COLOR="#FF0000">All functions are atomic</FONT></H4>

<P><FONT COLOR="#FF0000">All Credentials Cache API functions must be
atomic.</FONT></P>

<P><B><FONT COLOR="#FF0000">Windows</FONT></B></P>

<P><FONT COLOR="#FF0000">DLLs should be named KrbCC16.dll and
KrbCC32.dll.</FONT></P>

<P>
<HR>
<A NAME="FunctionDefinitions"></A></P>

<H2>Function definitions</H2>

<P><A NAME="MainCacheFunctions"></A></P>

<H3>Main Cache Functions</H3>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_initialize                                                                    --><!-- ----------------------------------------------------------------------------------->
</P>

<BLOCKQUOTE><DL>
   <DD>980724 - TDH
   
   <DD><B>Note: missing definition for cc_get_instance and
   cc_free_instance..</B>
   
   <DD><B>this is due two added functions in Steve Rothwell's
   implementation of the ccache. The functions are not apart of the
   API, but are noted here because they are used in Steve's
   implementation for Windows NT/95.</B>
   
   <DD>cc_get_instance
   
   <DD>cc_get_instance (apiCB* cc_ctx, char** instance)
   
   <DD>cc_free_instance
   
   <DD>cc_free_instance (apiCB* cc_ctx, char** instance)
</DL></BLOCKQUOTE>

<P><A NAME="cc_initialize"></A></P>

<H4>cc_initialize</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_initialize(apiCB** cc_ctx, <FONT
COLOR="#FF0000">cc_int32</FONT> api_version, <FONT
COLOR="#FF0000">cc_int32</FONT>* api_supported, char** vendor)</PRE>

<P>This function performs any initialization required by the
<I>API</I>. It must be called before any other function in the
<I>API</I> is called. The cc_ctx returned by this function <FONT
COLOR="#FF0000">must</FONT> be passed to all other <I>API</I>
functions as the first argument.</P>

<P><FONT COLOR="#FF0000">The application must pass in the maximum
version number of the API it supports in the </FONT><B><FONT
COLOR="#FF0000">api_version</FONT></B><FONT COLOR="#FF0000">
parameter.</FONT></P>

<P><FONT COLOR="#FF0000">If </FONT><B><FONT
COLOR="#FF0000">api_supported</FONT></B><FONT COLOR="#FF0000">
non-NULL, then cc_initialize will store the maximum API version
number supported by the library implementing the API there.</FONT>
</P>

<P><FONT COLOR="#FF0000">If the version requested by </FONT><B><FONT
COLOR="#FF0000">api_version</FONT></B><FONT COLOR="#FF0000"> is not
equal to the version supported by the library, CC_BAD_API_VERSION
will be returned as the error code (along with the version the
library does support in </FONT><B><FONT
COLOR="#FF0000">api_supported</FONT></B><FONT
COLOR="#FF0000">).</FONT></P>

<P>If the <B>vendor</B> is non-NULL, then cc_initialize will store a
pointer to a read/only C string which contains a string describing
the vendor which implemented the credentials cache <I>API</I>.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NOMEM, CC_BAD_API_VERSION, CC_BAD_PARM</P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_shutdown  		                                                              --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_shutdown"></A></P>

<H4>cc_shutdown</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_shutdown(apiCB** cc_ctx)</PRE>

<P>This function performs any cleanup required by the <I>API</I>.
cc_ctx will be NULL on return. The application program must call
cc_initialize() again before making any credentials cache <I>API</I>
calls.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_get_change_time                                                               --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_get_change_time"></A></P>

<H4>cc_get_change_time</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_get_change_time(apiCB* cc_ctx, cc_time_t* time)</PRE>

<P>This function returns the time of the most recent change for the
entire cache. There is ONE timestamp maintained for the entire cache.
By maintaining a local copy the caller can deduce whether "something
changed" or not. <I>"descriptive text to talk about possible
implementation problems" to be supplied by pbh</I></P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, CC_NOMEM, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_get_NC_info  	                                                              --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_get_NC_info"></A></P>

<H4>cc_get_NC_info</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_get_NC_info(apiCB* cc_ctx, <FONT
COLOR="#FF0000">infoNC*** ppNCi</FONT>)</PRE>

<P>cc_get_NC_info() is a wrapper for cc_seq_fetch_NCs(),
cc_get_name() cc_get_cred_version(), and cc_get_principal(). It
returns all the information needed to uniquely identify each NC in
the cache (name and cred_version) and the associated principal.
Specifically it returns a null terminated list of pointers to infoNC
structs. Each infoNC struct contain a pointer to the NC's name, a
pointer to the the principal associated with the NC, and the version
number (as an enumerated type) of the credentials stored in this NC.
</P>

<P>The ppNCi (the entire data structure) aquired by this routine
should be freed with cc_free_NC_info().</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, CC_NOMEM, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_open      		                                                              --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_open"></A></P>

<H4>cc_open</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_open(apiCB* cc_ctx, <FONT
COLOR="#FF0000">const char* name</FONT>, <FONT
COLOR="#FF0000">cc_int32 cred_vers, cc_uint32 cc_flags</FONT>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccache_p** ccache_pointer)</PRE>

<P>Opens an already exising NC identified by both <B>name</B>, and
<B>cred_vers</B>. It fills in the parameter **ccache_pointer with a
pointer to the NC.</P>

<P>The list of cache names, principals, and credentials versions may
be retrieved via cc_seq_fetch_NCs(), cc_get_name(),
cc_get_cred_version(), &amp; cc_get_principal() OR via
cc_get_NC_info().</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_BADNAME, CC_NO_EXIST, CC_NOMEM, <FONT
COLOR="#FF0000">CC_ERR_CRED_VERSION</FONT>, <FONT
COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_create                                                                        --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_create"></A></P>

<H4>cc_create</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_create(apiCB* cc_ctx, <FONT
COLOR="#FF0000">const char* name, const char* principal,</FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT
COLOR="#FF0000">cc_int32 cred_vers, cc_uint32 cc_flags,</FONT> ccache_p** ccache_pointer)</PRE>

<P>Create a new NC. The NC is uniquely identified by the combination
of it's name and the "cc_creds_vers" (i.e. which credentials version
it holds). The principal given is also associated with the NC. A NULL
<B>name</B> is not allowed. <FONT COLOR="#FF0000">If </FONT><B><FONT
COLOR="#FF0000">name</FONT></B><FONT COLOR="#FF0000"> is non-null and
there is already a NC named </FONT><B><FONT
COLOR="#FF0000">name</FONT></B><FONT COLOR="#FF0000">, all
credentials in the cache are removed, and handle for the existing
cache is returned. If there is already a NC named name, all existing
handles for this cache remain valid.</FONT> The NC is created with a
primary principal specified by <B>principal</B>.(NOTE: The alpha
implementation does not do this. If same name/vers is used,
CC_BADNAME is returned.</P>

<P>The "name" of an NC is expected to be of the form
&lt;principal&gt;[.&lt;instance&gt;]@&lt;realm&gt; (e.g.
phonebone@madmagazine.com). This syntax is not currently enforced.
But without a common, agreed upon naming scheme, the usefullness of a
shared cache is greatly diminished. The intent is that calling code
should be able to easily infer which NC to use (i.e. open or create).
</P>

<P>An NC is intended to hold credentials for a single principal in a
single realm, and for a single credentials version (i.e. V4 or V5).
The cache can contain credentials for other credential versions,
other realms, and even other principals, but each in a separate NC.
This rule will allow callers that can only handle a single principal
in a single realm to continue to work by dealing with only one NC.
Callers that can deal with multiple principals, multiple realms,
and/or multiple credentials versions can do so by dealing with
multiple NCs. By doing it this way, the callers that are able to
handle multiple principals, realms, and/or versions can do so without
interfering with "differently abled" code.</P>

<P><I>The two preceding paragraphs need revision. We are working on
reaching consensus and will revise when reached.</I></P>

<P>The list of cache names, principals, &amp; cred_versions may be
retrieved via cc_get_NC_info().</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_BADNAME, CC_BAD_PARM, CC_NO_EXIST, CC_NOMEM, <FONT
COLOR="#FF0000">CC_ERR_CRED_VERSION</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_close                                                                         --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_close"></A></P>

<H4>cc_close</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_close(apiCB* cc_ctx, ccache_p** ccache_pointer)</PRE>

<P>Close the NC. The <B>ccache_pointer</B> related memory is
deallocated, and ccache_pointer is set to NULL before being returned
to caller.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_destroy                                                                       --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_destroy"></A></P>

<H4>cc_destroy</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_destroy(apiCB* cc_ctx, ccache_p** ccache_pointer)</PRE>

<P>Destroy the NC pointed to by <B>ccache_pointer</B>. The
<B>ccache_pointer</B> related memory is deallocated, and
ccache_pointer is set to NULL before being returned to caller.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_seq_fetch_NCs                                                                 --><!-- -----------------------------------------------------------------------------------><BR>

</P>

<P><A NAME="cc_seq_fetch_NCs_begin"></A></P>

<H4><FONT COLOR="#FF0000">cc_seq_fetch_NCs_begin</FONT></H4>

<PRE><FONT
COLOR="#FF0000">cc_int32 cc_seq_fetch_NCs_begin(apiCB* cc_ctx, ccache_cit** itNCs)</FONT></PRE>

<P><FONT COLOR="#FF0000">Used to allocate memory and initialize the
iterator *itNCs. Use cc_seq_fetch_NCs_end() to deallocate the memory
used by *itNCs.</FONT></P>

<P><FONT COLOR="#FF0000">Possible error codes: CC_NOERROR,
CC_NO_EXIST, CC_BAD_PARM, CC_NOMEM</FONT></P>

<H4><FONT COLOR="#FF0000"><A NAME="cc_seq_fetch_NCs_next"></A></FONT>
</H4>

<H4><FONT COLOR="#FF0000">cc_seq_fetch_NCs_next</FONT></H4>

<PRE><FONT
COLOR="#FF0000">cc_int32 cc_seq_fetch_NCs_next(apiCB* cc_ctx, ccache_p** ccache_pointer, ccache_cit* itNCs)</FONT></PRE>

<P><FONT COLOR="#FF0000">Used to sequentially open every NC in the
cache.</FONT></P>

<P><FONT COLOR="#FF0000">Ccache_pointer must be a pointer to a
ccache_p*. The ccache_pointer returned may be used to get information
about the NC by calling cc_get_name(), cc_get_cred_version(), and
cc_get_principal(). Ccache_pointer's returned must be freed via
cc_close() between calls to cc_seq_fetch_NCs_next().</FONT></P>

<P><FONT COLOR="#FF0000">itNCs must be a pointer to a ccache_cit*
variable provided by the calling application and which is used by
cc_seq_fetch_NCs_next() to determine the next NC to return. It must
have been initialized by cc_seq_fetch_NCs_begin().</FONT></P>

<P><FONT COLOR="#FF0000">If changes are made to the credentials cache
while it iterator is being used, it must return at least the
intersection, and at most the union, of the set of NC's that were in
the cache when the iteration began and the set of NC's that are in
the cache when it ends.</FONT></P>

<P><FONT COLOR="#FF0000">When the last NC in the sequence is
returned, the return code from cc_seq_fetch_NCs_next() will be
CC_END.</FONT></P>

<P><FONT COLOR="#FF0000">Possible error codes: CC_NOERROR, CC_END,
CC_NO_EXIST. CC_BAD_PARM, CC_NOMEM</FONT></P>

<H4><FONT COLOR="#FF0000">&nbsp;</FONT></H4>

<H4><FONT COLOR="#FF0000"><A NAME="cc_seq_fetch_NCs_end"></A></FONT>
</H4>

<H4><FONT COLOR="#FF0000">cc_seq_fetch_NCs_end</FONT></H4>

<PRE><FONT
COLOR="#FF0000">cc_int32 cc_seq_fetch_NCs_end(apiCB* cc_ctx, ccache_cit** itNCs)</FONT></PRE>

<P><FONT COLOR="#FF0000">Deallocates the memory used by *itNCs, and
sets *itNCs to NULL.</FONT></P>

<P><FONT COLOR="#FF0000">Possible error codes: CC_NOERROR,
CC_NO_EXIST, CC_BAD_PARM</FONT></P>

<P>&nbsp;</P>

<P><A NAME="NCFunctions"></A></P>

<H3>NC Functions</H3>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_get_name                                                                      --><!-- -----------------------------------------------------------------------------------><A NAME="cc_get_name"></A>
</P>

<H4>cc_get_name</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_get_name(apiCB* cc_ctx, const ccache_p* ccache_pointer, char** name)</PRE>

<P>cc_get_name() returns the name of the NC indicated by
ccache_pointer. The name can be used in cc_open() or cc_create(). The
combination of the name and the credentials version uniqeuly identify
an NC. The returned name should be freed via cc_free_name().</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NOMEM, CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_get_cred_version                                                              --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_get_cred_version"></A></P>

<H4>cc_get_cred_version</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_get_cred_version(apiCB* cc_ctx, const ccache_p* ccache_pointer, <FONT
COLOR="#FF0000">cc_int32* cred_vers</FONT>)</PRE>

<P>cc_get_cred_version() returns one of the enumerated type
cc_cred_vers in cred_vers. The expected values are CC_CRED_V4, or
CC_CRED_V5. The combination of the name and the credentials version
uniquely identify an NC.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_set_principal                                                                 --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_set_principal"></A></P>

<H4>cc_set_principal</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_set_principal(apiCB* cc_ctx, const ccache_p* ccache_pointer, <FONT
COLOR="#FF0000">const cc_int32 cred_vers</FONT>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char* principal)</PRE>

<P>Set the primary principal for the NC indicated by ccache_pointer.
This is the complement to cc_get_principal().</P>

<P>cred_vers is used as a double check.</P>

<P>principal points to a null terminated string that will be copied
into the NC. This new principal will be returned if you call
cc_get_principal() for this NC.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NOMEM, CC_NO_EXIST, CC_ERR_CRED_VERSION, <FONT
COLOR="#FF0000">CC_BAD_PARM</FONT><BR>

&nbsp;</P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_get_principal                                                                 --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_get_principal"></A></P>

<H4>cc_get_principal</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_get_principal(apiCB* cc_ctx, const ccache_p* ccache_pointer, char** principal)</PRE>

<P>Return the primary principal for the NC that was set via
cc_create() or cc_set_principal(). The returned principal should be
freed via cc_free_principal() .</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NOMEM, CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT><BR>

</P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_store                                                                         --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_store"></A></P>

<H4>cc_store</H4>

<PRE><FONT COLOR="#FF0000">cc_int32</FONT> cc_store(<FONT
COLOR="#FF0000">apiCB* cc_ctx, ccache_p* ccache_pointer, const&nbsp;</FONT><FONT
COLOR="#FF0000"><A HREF="#unionCred_union">cred_union</A></FONT><FONT
COLOR="#FF0000"> cred</FONT>)</PRE>

<P>Store (make a copy of) <B>cred</B> in the NC indicated by
<B>ccache_pointer</B>.</P>

<P>A cred_union contains a cred_type indicator and a cred_ptr_union.
A cred_ptr_union can contain either a V4Cred_type pointer or a
cc_creds (V5 creds) pointer. Cred_type indicates which type of
pointer is in the cred_ptr_union. This also allows the <I>API</I> to
enforce the credentials version declared in cc_create() or cc_open().
</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, CC_ERR_CACHE_FULL, CC_ERR_CRED_VERSION, <FONT
COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_remove_cred                                                                   --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_remove_cred"></A></P>

<H4>cc_remove_cred</H4>

<PRE><FONT COLOR="#FF0000">cc_int32</FONT> cc_remove_cred(<FONT
COLOR="#FF0000">apiCB* cc_ctx, ccache_p* ccache_pointer, const </FONT><FONT
COLOR="#FF0000"><A HREF="#unionCred_union">cred_union</A></FONT><FONT
COLOR="#FF0000"> cred</FONT>)</PRE>

<P>Removes the credential <B>cred</B> from <B>ccache_pointer</B>. The
credentials in the NC indicated by ccache_pointer are searched to
find a matching credential. If found, that credential is removed from
the NC. The cred parameter is not modified and should be freed via
cc_free_creds(). It is legitimate to call this function during a
sequential fetch, and the deletion of a credential already returned
by cc_seq_fetch_creds() should not disturb sequence of credentials
returned by cc_seq_fetch_creds().</P>

<P>Use of cred_union is the same as is explained in cc_store().</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, CC_NOTFOUND, CC_ERR_CRED_VERSION, <FONT
COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_seq_fetch_creds                                                               --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_seq_fetch_creds_begin"></A></P>

<H4><FONT COLOR="#FF0000">cc_seq_fetch_creds_begin</FONT></H4>

<PRE><FONT
COLOR="#FF0000">cc_int32 cc_seq_fetch_creds_begin(apiCB* cc_ctx, const ccache_p* ccache_pointer, ccache_cit** itCreds)</FONT></PRE>

<P><FONT COLOR="#FF0000">Allocates memory for and initializes
*itCreds. This memory must be deallocated using
cc_seq_fetch_creds_end().</FONT></P>

<P><FONT COLOR="#FF0000">Ccache_pointer must be a valid pointer to
the NC containing the creds to be returned by the iterator.</FONT>
</P>

<P><FONT COLOR="#FF0000">Possible error codes: CC_NOERROR,
CC_NO_EXIST, CC_BAD_PARM, CC_NOMEM</FONT></P>

<P>&nbsp;</P>

<P><A NAME="cc_seq_fetch_creds_next"></A></P>

<H4><FONT COLOR="#FF0000">cc_seq_fetch_creds_next</FONT></H4>

<PRE><FONT
COLOR="#FF0000">cc_int32 cc_seq_fetch_creds_next(apiCB* cc_ctx, cred_union** cred, ccache_cit* itCreds)</FONT></PRE>

<P><FONT COLOR="#FF0000">cc_seq_fetch_creds_next() is used to
sequentially read every set of credentials in an NC. The NC has been
indicated in the call to cc_seq_fetch_creds_begin().</FONT></P>

<P><FONT COLOR="#FF0000">itCreds must be a pointer to a ccache_cit*
variable provided by the calling application and which is used by
cc_seq_fetch_creds_next() to determine the next cached credential to
return. The ccache_cit* variable must be initialized by calling
cc_seq_fetch_creds_begin().</FONT></P>

<P><FONT COLOR="#FF0000">The credentials are filled into the
cred_union pointed to by creds. Note that the cred_union contains
elements which are dynamically allocated, so must be freed using
cc_free_creds() between calls to cc_seq_fetch_creds_next().</FONT>
</P>

<P><FONT COLOR="#FF0000">If changes are made to the NC while it
iterator is being used, it must return at least the intersection, and
at most the union, of the set of credentials that were in the NC when
the iteration began and the set of credentials that are in the NC
when it ends.</FONT></P>

<P><FONT COLOR="#FF0000">When the last credential in the sequence is
returned, the return code from cc_seq_fetch_creds_next() will be
CC_END.</FONT></P>

<P><FONT COLOR="#FF0000">Possible error codes: CC_NOERROR, CC_END,
CC_NO_EXIST, CC_BAD_PARM, CC_NOMEM</FONT></P>

<P>&nbsp;</P>

<P><A NAME="cc_seq_fetch_creds_end"></A></P>

<H4><FONT COLOR="#FF0000">cc_seq_fetch_creds_end</FONT></H4>

<PRE><FONT
COLOR="#FF0000">cc_int32 cc_seq_fetch_creds_end(apiCB* cc_ctx, ccache_cit** itCreds)</FONT></PRE>

<P><FONT COLOR="#FF0000">Deallocates memory used by *itCreds and sets
*itCreds to NULL.</FONT></P>

<P><FONT COLOR="#FF0000">Possible error codes: CC_NOERROR,
CC_NO_EXIST, CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_lock_request                                                                  --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_lock_request"></A></P>

<H4>cc_lock_request</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_lock_request(apiCB* cc_ctx, const ccache_p* ccache_pointer, <FONT
COLOR="#FF0000">cc_int32</FONT> lock_type)</PRE>

<DL>
   <DD>99/02/11 - smcguire
   
   <DD><B>As of&nbsp;this date there is no locking in the Win NT/95
   or Machintosh implementations. The description below may not be
   completely accurate as to how this function should be
   implemented.</B>
</DL>

<P>This function is currently NOT IMPLEMENTED. All functions attach
to the cache, take action, and detach from the cache before returning
to the caller.</P>

<P>This function will lock or unlock the NC based on the argument
value of lock_type:</P>

<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CC_LOCK_UNLOCK&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unlock the NC
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CC_LOCK_READER&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lock the NC for reading
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CC_LOCK_WRITER&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lock the NC for writing
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CC_LOCK_NOBLOCK 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Don't block, but return an error code if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the request cannot be satisfied.
&nbsp;</PRE>

<P>Locking is done on a per-thread basis. At most one thread may have
the credentials locked for writing; if so, there must not be any
threads that have the credentials locked for reading.</P>

<P>Multiple threads may have the cache locked for reading, as long as
there is not a writer lock asserted on the cache.</P>

<P>If a thread has a cache locked for reading, that lock may be
upgraded to a writer lock by calling cc_lock_request() with a
lock_type of CC_LOCK_WRITER. If a thread has the cache locked for
reading or writing, a request to cc_lock_request() for a reader or
writer lock, respectively, is a no-op. If a thread does not have the
cache locked, and calls cc_lock_request() with a lock_type of
CC_LOCK_UNLOCK, this is also a no-op.</P>

<P>A request for CC_LOCK_READER and CC_LOCK_WRITER may be made
non-blocking by logical or'ing the value CC_LOCK_NOBLOCK. In that
case, if it is not possible to satisfy the lock request, the error
CC_LOCKED will be returned.</P>

<P>&nbsp;</P>

<P><A NAME="LiberationFunctions"></A></P>

<H3>Liberation Functions</H3>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_free_principal                                                                --><!-- -----------------------------------------------------------------------------------><A NAME="cc_free_principal"></A>
</P>

<H4>cc_free_principal</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_free_principal(apiCB* cc_ctx, <FONT
COLOR="#FF0000">char** principal</FONT>)</PRE>

<P>This function frees the <B>principal</B> returned by
cc_get_principal() and sets *principal to NULL.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_free_name                                                                     --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_free_name"></A></P>

<H4>cc_free_name</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_free_name(apiCB* cc_ctx, <FONT
COLOR="#FF0000">char** name</FONT>)</PRE>

<P>This function frees the <B>name</B> returned by cc_get_name() and
sets *name to NULL.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_free_creds                                                                    --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_free_creds"></A></P>

<H4>cc_free_creds</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_free_creds(apiCB* cc_ctx, cred_union** creds)</PRE>

<P>This function frees all storage associated with creds returned by
cc_seq_fetch_creds() and sets the creds pointer to NULL.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>

<P><!-- -----------------------------------------------------------------------------------><!-- cc_free_NC_info                                                                  --><!-- -----------------------------------------------------------------------------------><BR>

<A NAME="cc_free_NC_info"></A></P>

<H4>cc_free_NC_info</H4>

<PRE><FONT
COLOR="#FF0000">cc_int32</FONT> cc_free_NC_info(apiCB* cc_ctx, <FONT
COLOR="#FF0000">infoNC*** ppNCi</FONT>)</PRE>

<P>This routine frees all storage aquired by cc_get_NC_info() and
sets ppNCi to NULL.</P>

<P>Possible error codes: <FONT COLOR="#FF0000">CC_NOERROR,</FONT>
CC_NO_EXIST, <FONT COLOR="#FF0000">CC_BAD_PARM</FONT></P>
</BODY>
</HTML>
